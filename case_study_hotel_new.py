# -*- coding: utf-8 -*-
"""Case study_hotel_new.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GkwrUAlVoqpc9A6mQJBgpE3kQuGl1Iwg
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib
import matplotlib.pyplot as plt
from sklearn import preprocessing
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, plot_confusion_matrix
from sklearn import metrics
import plotly.express as px
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import warnings
warnings.filterwarnings('ignore')
import missingno as msno

# Data Description
#    hotel (str) - Hotel (H1 = Resort Hotel or H2 = City Hotel)
#    lead_time (int) - Number of days that elapsed between the entering date of the booking into the PMS and the arrival date
#    arrival_date_year (int) - Year of arrival date
#    arrival_date_month (str) - Month of arrival date
#    arrival_date_week_number (int) - Week number of year for arrival date
#    arrival_date_day_of_month (int) - Day of arrival date
#    stays_in_weekend_nights (int) - Number of weekend nights (Saturday or Sunday) the guest stayed or booked to stay at the hotel
#    stays_in_week_nights (int) - Number of week nights (Monday to Friday) the guest stayed or booked to stay at the hotel
#    adults (int) - Number of adults
#    children (float) - Number of children
#    babies (int) - Number of babies
#    meal (str) - Type of meal booked. Categories are presented in standard hospitality meal packages: (Undefined/SC = no meal package, BB = Bed & Breakfast, HB = Half board – breakfast and one other meal - usually dinner, FB = Full board – breakfast, lunch and dinner)
#    country (str) - Country of origin. Categories are represented in the ISO 3155–3:2013 format
#    market_segment (str) - Market segment designation (TA = Travel Agents, TO = Tour Operators)
#    distribution_channel (str) - Booking distribution channel (TA = Travel Agents, TO = Tour Operators)
#    is_repeated_guest (int) - Value indicating if the booking name was from a repeated guest (1) or not (0)
#    previous_cancellations (int) - Number of previous bookings that were cancelled by the customer prior to the current booking
#    previous_bookings_not_canceled (int) - Number of previous bookings not cancelled by the customer prior to the current booking
#    reserved_room_type (str) - Code of room type reserved. Code is presented instead of designation for anonymity reasons
#    assigned_room_type (str) - Code for the type of room assigned to the booking. Sometimes the assigned room type differs from the reserved room type due to hotel operation reasons (e.g. overbooking) or by customer request. Code is presented instead of designation for anonymity reasons
#    booking_changes (int) - Number of changes/amendments made to the booking from the moment the booking was entered on the PMS until the moment of check-in or cancellation
#    deposit_type (str) - Indication on if the customer made a deposit to guarantee the booking. This variable can assume three categories: (No Deposit = no deposit was made, Non Refund = a deposit was made in the value of the total stay cost, Refundable = a deposit was made with a value under the total cost of stay)
#    agent (float) - ID of the travel agency that made the booking
#    company (float) - ID of the company/entity that made the booking or responsible for paying the booking. ID is presented instead of designation for anonymity reasons
#    days_in_waiting_list (int) - Number of days the booking was in the waiting list before it was confirmed to the customer
#    customer_type (str) - Type of booking, assuming one of four categories: (Contract = when the booking has an allotment or other type of contract associated to it, Group = when the booking is associated to a group, Transient = when the booking is not part of a group or contract, and is not associated to other transient booking, Transient-party = when the booking is transient, but is associated to at least other transient booking
#    adr (float) - Average Daily Rate as defined by dividing the sum of all lodging transactions by the total number of staying nights
#    required_car_parking_spaces (int) - Number of car parking spaces required by the customer
#    total_of_special_requests (int) - Number of special requests made by the customer (e.g. twin bed or high floor)
#    reservation_status (str) - Reservation last status, assuming one of three categories: (Canceled = booking was canceled by the customer, Check-Out = customer has checked in but already departed, No-Show = customer did not check-in and did inform the hotel of the reason why)
#    reservation_status_date (str) - Date at which the last status was set. This variable can be used in conjunction with the ReservationStatus to understand when was the booking canceled or when did the customer checked-out of the hotel

path = "hotel_bookings.csv"

df = pd.read_csv(path)
df_copy = df.copy()

df.describe()

df.info()

df.head()

# checking for null values 

null = pd.DataFrame({'Null Values' : df.isna().sum(), 'Percentage Null Values' : (df.isna().sum()) / (df.shape[0]) * (100)})
null

# filling null values with zero

df.fillna(0, inplace = True)

null = pd.DataFrame({'Null Values' : df.isna().sum(), 'Percentage Null Values' : (df.isna().sum()) / (df.shape[0]) * (100)})
null

df[df.adults == 0]

filter = (df.children == 0) & (df.adults == 0) & (df.babies == 0)
df[filter]

df = df[~filter]
df

data = df[df['is_canceled'] == 0] #not canceled

px.box(data_frame = data, x = 'reserved_room_type', y = 'adr', color = 'hotel', template = 'plotly_dark')

data_resort = df[(df['hotel'] == 'Resort Hotel') & (df['is_canceled'] == 0)] #not canceled 
data_city = df[(df['hotel'] == 'City Hotel') & (df['is_canceled'] == 0)] #not canceled

resort_hotel = data_resort.groupby(['arrival_date_month'])['adr'].mean().reset_index()
resort_hotel

city_hotel=data_city.groupby(['arrival_date_month'])['adr'].mean().reset_index()
city_hotel

final_hotel = resort_hotel.merge(city_hotel, on = 'arrival_date_month')
final_hotel.columns = ['month', 'price_for_resort', 'price_for_city_hotel']
final_hotel

!pip install sort-dataframeby-monthorweek

!pip install sorted-months-weekdays

import sort_dataframeby_monthorweek as sd

def sort_month(df, column_name):
    return sd.Sort_Dataframeby_Month(df, column_name)

final_prices = sort_month(final_hotel, 'month')
final_prices

plt.figure(figsize = (17, 8))

px.line(final_prices, x = 'month', y = ['price_for_resort','price_for_city_hotel'],
        title = 'Price of room per night over the months', template = 'plotly_dark')

resort_guests = data_resort['arrival_date_month'].value_counts().reset_index()
resort_guests.columns=['month','num of guests']
resort_guests

city_guests = data_city['arrival_date_month'].value_counts().reset_index()
city_guests.columns=['month','num of guests']
city_guests

final_guests = resort_guests.merge(city_guests,on='month')
final_guests.columns=['month','num of guests in resort','num of guest in city hotel']
final_guests

final_guests = sort_month(final_guests,'month')
final_guests

px.line(final_guests, x = 'month', y = ['num of guests in resort','num of guest in city hotel'],
        title='Total number of guests per Months', template = 'plotly_dark')

filter = df['is_canceled'] == 0
data = df[filter]
data.head()

data['total_nights'] = data['stays_in_weekend_nights'] + data['stays_in_week_nights']
data.head()

stay = data.groupby(['total_nights', 'hotel']).agg('count').reset_index()
stay = stay.iloc[:, :3]
stay = stay.rename(columns={'is_canceled':'Number of stays'})
stay

px.bar(data_frame = stay, x = 'total_nights', y = 'Number of stays', color = 'hotel', barmode = 'group',
        template = 'plotly_dark')

plt.figure(figsize = (24, 12))

corr = df.corr()
sns.heatmap(corr, annot = True, linewidths = 1)
plt.show()

correlation = df.corr()['is_canceled'].abs().sort_values(ascending = False)
correlation

useless_col =['arrival_date_year', 'country', 'booking_changes', 'reservation_status', 'assigned_room_type'
#,'company,stays in weekend nights', 'stays in week nights', 'deposit type', 'country, reserved room type', 'reservation status dat'
              ]
df.drop(useless_col, axis = 1, inplace = True)



# creating numerical and categorical dataframes

cat_cols = [col for col in df.columns if df[col].dtype == 'O']
cat_cols

cat_df = df[cat_cols]
cat_df.head()

cat_df['reservation_status_date'] = pd.to_datetime(cat_df['reservation_status_date'])

cat_df['year'] = cat_df['reservation_status_date'].dt.year
cat_df['month'] = cat_df['reservation_status_date'].dt.month
cat_df['day'] = cat_df['reservation_status_date'].dt.day

cat_df.drop(['reservation_status_date'] , axis = 1, inplace = True)

cat_df.head()

# printing unique values of each column
for col in cat_df.columns:
    print(f"{col}: \n{cat_df[col].unique()}\n")

# encoding categorical variables

cat_df['hotel'] = cat_df['hotel'].map({'Resort Hotel' : 0, 'City Hotel' : 1})

cat_df['meal'] = cat_df['meal'].map({'BB' : 0, 'FB': 1, 'HB': 2, 'SC': 3, 'Undefined': 4})

cat_df['market_segment'] = cat_df['market_segment'].map({'Direct': 0, 'Corporate': 1, 'Online TA': 2, 'Offline TA/TO': 3,
                                                           'Complementary': 4, 'Groups': 5, 'Undefined': 6, 'Aviation': 7})

cat_df['distribution_channel'] = cat_df['distribution_channel'].map({'Direct': 0, 'Corporate': 1, 'TA/TO': 2, 'Undefined': 3,
                                                                       'GDS': 4})

cat_df['reserved_room_type'] = cat_df['reserved_room_type'].map({'C': 0, 'A': 1, 'D': 2, 'E': 3, 'G': 4, 'F': 5, 'H': 6,
                                                                   'L': 7, 'B': 8})

cat_df['deposit_type'] = cat_df['deposit_type'].map({'No Deposit': 0, 'Refundable': 1, 'Non Refund': 3})

cat_df['customer_type'] = cat_df['customer_type'].map({'Transient': 0, 'Contract': 1, 'Transient-Party': 2, 'Group': 3})

#cat_df['year'] = cat_df['year'].map({2015: 0, 2014: 1, 2016: 2, 2017: 3})

cat_df.head()

num_df = df.drop(columns = cat_cols, axis = 1) #agent and company are ID
num_df.drop('is_canceled', axis = 1, inplace = True)
num_df

num_df.var()

# normalizing too big numerical variables

num_df['lead_time'] = np.log(num_df['lead_time'] + 1)
num_df['arrival_date_week_number'] = np.log(num_df['arrival_date_week_number'] + 1)
num_df['arrival_date_day_of_month'] = np.log(num_df['arrival_date_day_of_month'] + 1)
num_df['days_in_waiting_list'] = np.log(num_df['days_in_waiting_list'] + 1)
num_df['agent'] = np.log(num_df['agent'] + 1)
num_df['company'] = np.log(num_df['company'] + 1)
num_df['adr'] = np.log(num_df['adr'] + 1)

num_df.var()

# null = X.isna().sum()
# null

num_df['adr'] = num_df['adr'].fillna(value = num_df['adr'].mean()) #one null variable

X = pd.concat([cat_df, num_df], axis = 1)
y = df['is_canceled']

test_col = ['company','month','year','day' ,'stays_in_weekend_nights', "stays_in_week_nights"
              ]
X.drop(test_col, axis = 1, inplace = True)

X.drop(['deposit_type', 'reserved_room_type'], axis =1 , inplace = True)

X['family'] = X['children'] + X["adults"] + X['babies']

X.drop(['children', 'adults', 'babies'], axis =1 , inplace = True)

X

X.shape, y.shape

X

null = X.isna().sum()
null

#train, validation, and test

# T = pd.concat([X, y], axis = 1)

# T



# train, validate, test = np.split(T.sample(frac=1, random_state=1), [int(.6*len(df)), int(.8*len(df))]) #60, 20, 20

# train_y = train['is_canceled']
# validate_y = validate['is_canceled']
# test_y = test['is_canceled']

# train.drop('is_canceled', axis = 1, inplace = True)
# validate.drop('is_canceled', axis = 1, inplace = True)
# test.drop('is_canceled', axis = 1, inplace = True)

# T_y = T['is_canceled']

# T_y

# T.drop('is_canceled', axis = 1, inplace = True)

# T.head()

#another way



X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20, shuffle=True)

X

X_train

X_test

X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.25, random_state=1) # 0.25 x 0.8 = 0.2

from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.linear_model import LogisticRegression

#Logistic Regression
lr = LogisticRegression()
lr.fit(X_train, y_train)

y_pred_lr = lr.predict(X_val)

acc_lr = accuracy_score(y_val, y_pred_lr) #validation test
conf = confusion_matrix(y_val, y_pred_lr)
clf_report = classification_report(y_val, y_pred_lr)

print(f"Accuracy Score of Logistic Regression is : {acc_lr}")
print(f"Confusion Matrix : \n{conf}")
print(f"Classification Report : \n{clf_report}")

#77%

#ANN-simple layer

from tensorflow.keras.utils import to_categorical #binary class matrix

X = pd.concat([cat_df, num_df], axis = 1)
y = to_categorical(df['is_canceled'])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20)
X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.25, random_state=1) #60, 20, 20

import keras
from keras.layers import Dense
from keras.models import Sequential

model  = Sequential()
model.add(Dense(100, activation = 'relu', input_shape = (27, )))
model.add(Dense(100, activation = 'relu'))
model.add(Dense(2, activation = 'sigmoid'))
model.compile(optimizer = 'adam', loss = 'binary_crossentropy', metrics = ['accuracy'])
model_history = model.fit(X_train, y_train, validation_data = (X_val, y_val),
                          epochs = 100)
#unfold_lessHide output

plt.figure(figsize = (12, 6))

train_loss = model_history.history['loss']
val_loss = model_history.history['val_loss'] 
epoch = range(1, 101)

loss = pd.DataFrame({'train_loss' : train_loss, 'val_loss' : val_loss})

px.line(data_frame = loss, x = epoch, y = ['val_loss', 'train_loss'], title = 'Training and Validation Loss',
        template = 'plotly_dark')

plt.figure(figsize = (12, 6))

train_acc = model_history.history['accuracy']
val_acc = model_history.history['val_accuracy'] 
epoch = range(1, 101)


accuracy = pd.DataFrame({'train_acc' : train_acc, 'val_acc' : val_acc})

px.line(data_frame = accuracy, x = epoch, y = ['val_acc', 'train_acc'], title = 'Training and Validation Accuracy',
        template = 'plotly_dark')

acc_ann = model.evaluate(X_test, y_test)[1]

print(f'Accuracy of model is {acc_ann}')

#98.6%

